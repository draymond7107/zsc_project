代理模式
    代理模式就是多一个代理类出来，替原对象进行一些操作。并且能加强原方法的功能。
    目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。
    要点：
        1：接口
        2：接口的实现类
        3：代理类

    静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。
    动态代理：在程序运行时运用反射机制动态创建而成。

    静态代理：
        代理类要注入一个目标对象
        优点：
            代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合）
        缺点：
            1：代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，
                除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。
            2：代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。
                如上的代码是只为HuaWei类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。
            3：即静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。


    动态代理
        通过一个代理类完成全部的代理功能，那么我们就需要用动态代理
        动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象

        在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 类的支持
        InvocationHandler：每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法


    3:代理模式的角色与职责
        subject（抽象主题角色）
            真实主题与代理主题的共同接口
        realSubject(真实主题角色)
            定义了代理角色所代表的真实的对象
        Proxy(代理主题角色)
            含有对真实主题的引用，代理角色通常将客户端调用传递给真实主题对象之前或者之后执行某些操作，二不是单纯的返回真实的对象



